<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Custom Video Player</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- HLS.js for .m3u8 support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        :root {
            --player-accent-color: #FF9500;
            --player-controls-bg: rgba(0, 0, 0, 0.7);
            --player-text-color: #FFFFFF;
            --player-icon-size: 1.2em;
            --player-mobile-icon-size: 1.5em;
            --marker-intro-color: #3498db;
            --marker-outro-color: #e74c3c;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: #141414;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-player-container {
            width: 90vw;
            max-width: 1000px;
            aspect-ratio: 16 / 9;
            position: relative;
            background-color: #000;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .video-player-container.fullscreen-mode,
        .video-player-container.fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            max-height: none !important;
            top: 0 !important;
            left: 0 !important;
            border-radius: 0 !important;
            z-index: 2147483647;
            position: fixed;
        }

        video#customPlayer {
            width: 100%;
            height: 100%;
            display: block;
            background: #000;
        }

        /* --- CAPTION STYLES --- */
        video#customPlayer::cue {
            background-color: rgba(0, 0, 0, 0.5);
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: 0.95em;
            line-height: 1.4;
            text-shadow: 0 1px 2px rgba(0,0,0,0.6);
        }
        video#customPlayer::-webkit-media-text-track-display { overflow: visible !important; }
        video#customPlayer::-webkit-media-text-track-container { overflow: visible !important; }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px 15px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 70%, rgba(0,0,0,0) 100%);
            display: flex;
            flex-direction: column;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
            z-index: 21;
        }

        .video-player-container:not(.controls-active) .video-controls {
            opacity: 0;
            pointer-events: none;
        }
        .video-player-container.paused .video-controls {
            opacity: 1;
            pointer-events: auto;
        }

        /* Progress Bar */
        .progress-bar-container {
            width: 100%;
            margin-bottom: 10px;
            cursor: pointer;
            padding: 10px 0;
            position: relative;
        }

        .progress-bar {
            width: 100%;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar-hover {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 3px;
            pointer-events: none;
            width: 0%;
            z-index: 1;
        }
        
        .progress-filled {
            height: 100%;
            background-color: var(--player-accent-color);
            border-radius: 3px;
            width: 0%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        .progress-filled::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background-color: var(--player-accent-color);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 3;
        }
        .video-player-container.controls-active .progress-filled::after { opacity: 1; }
        
        .skip-marker {
            position: absolute;
            top: 0;
            height: 100%;
            z-index: 1;
            opacity: 0.7;
        }
        .skip-marker.intro { background-color: var(--marker-intro-color); }
        .skip-marker.outro { background-color: var(--marker-outro-color); }

        .thumbnail-tooltip {
            position: absolute;
            bottom: 25px;
            left: 0;
            transform: translateX(-50%);
            background-color: #000;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            pointer-events: none;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 25;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        .thumbnail-image { background-repeat: no-repeat; }
        .thumbnail-time {
            width: 100%;
            background-color: rgba(0,0,0,0.8);
            color: #fff;
            text-align: center;
            font-size: 0.8em;
            padding: 3px 0;
        }

        .controls-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls-left, .controls-center, .controls-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .controls-center { flex-grow: 1; justify-content: center; }

        .control-button {
            background: none;
            border: none;
            color: var(--player-text-color);
            font-size: var(--player-icon-size);
            cursor: pointer;
            padding: 8px;
            line-height: 1;
            position: relative;
        }
        .control-button:hover, .control-button.active { color: var(--player-accent-color); }

        .time-display {
            color: var(--player-text-color);
            font-size: 0.85em;
            margin-left: 10px;
        }

        .volume-container { display: flex; align-items: center; }
        .volume-slider {
            width: 70px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            cursor: pointer;
            margin-left: 8px;
            display: none;
        }
        .video-player-container.desktop .volume-slider { display: block; }

        .big-play-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            color: var(--player-text-color);
            background-color: rgba(0,0,0,0.5);
            border-radius: 50%;
            width: 1.5em;
            height: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            transition: opacity 0.3s, transform 0.2s;
            padding: 0;
        }
        .big-play-button i { margin-left: 0.1em; }
        .big-play-button:hover { transform: translate(-50%, -50%) scale(1.1); }
        .video-player-container.playing .big-play-button,
        .video-player-container.has-interacted .big-play-button { opacity: 0; pointer-events: none; }
        
        .loading-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 19;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255,255,255,0.2);
            border-top-color: var(--player-accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading-text {
            color: var(--player-text-color);
            font-size: 1em;
            text-align: center;
        }
        .video-player-container.loading .loading-container,
        .video-player-container.processing .loading-container { display: flex; }
        .video-player-container.loading .big-play-button,
        .video-player-container.processing .big-play-button { display: none; }

        .seek-overlay {
            position: absolute;
            top: 0;
            width: 35%;
            height: calc(100% - 60px);
            z-index: 10;
        }
        .seek-overlay.left { left: 0; }
        .seek-overlay.right { right: 0; }
        .seek-feedback {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 2em;
            color: var(--player-text-color);
            background-color: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 22;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            pointer-events: none;
        }
        .seek-feedback.left { left: 20%; }
        .seek-feedback.right { right: 20%; }
        .seek-feedback.show { opacity: 1; }

        .skip-button {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background-color: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            z-index: 25;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: opacity 0.3s, transform 0.2s;
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
        }
        .skip-button.visible { opacity: 1; pointer-events: auto; transform: translateY(0); }
        .skip-button:hover { background-color: rgba(255, 255, 255, 0.1); }

        .captions-menu {
            position: absolute;
            bottom: 50px;
            right: 0;
            background-color: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 5px 0;
            display: none;
            flex-direction: column;
            min-width: 150px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 30;
        }
        .captions-menu.active { display: flex; }
        .caption-option {
            padding: 8px 15px;
            color: #ccc;
            cursor: pointer;
            font-size: 0.9em;
            text-align: left;
            background: none;
            border: none;
            width: 100%;
        }
        .caption-option.selected { color: var(--player-accent-color); font-weight: 500; }
        .caption-option:hover { background-color: rgba(255, 255, 255, 0.1); color: white; }
        
        /* --- FINISHED OVERLAY --- */
        .finished-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
            backdrop-filter: blur(5px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .finished-overlay.visible { display: flex; opacity: 1; pointer-events: auto; }
        .finished-overlay h2 { color: white; margin-bottom: 20px; font-weight: 600; letter-spacing: 0.5px; }
        .finished-btn {
            padding: 12px 30px;
            background: var(--player-accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1.1em;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: transform 0.2s, background-color 0.2s;
        }
        .finished-btn:hover { transform: scale(1.05); background-color: #ffaa33; }

        @keyframes spin { to { transform: rotate(360deg); } }
        @media (max-width: 768px) {
            .control-button { font-size: var(--player-mobile-icon-size); padding: 10px; }
            .controls-left .time-display { display: none; }
            .controls-right .time-display { font-size: 0.9em; }
            .volume-container { margin-right: 5px; }
            .volume-slider { display: none; }
            .big-play-button { font-size: 3em; }
            .controls-left, .controls-center, .controls-right { gap: 5px; }
            .seek-feedback { font-size: 1.5em; padding: 8px 15px;}
            .seek-feedback.left { left: 10%; }
            .seek-feedback.right { right: 10%; }
        }
    </style>
</head>
<body>

    <div class="video-player-container" id="videoPlayerContainer">
        <div class="loading-container" id="loadingContainer">
            <div class="spinner"></div>
            <p class="loading-text" id="loadingText"></p>
        </div>

        <!-- Finished Overlay -->
        <div class="finished-overlay" id="finishedOverlay">
            <h2>Episode Finished</h2>
            <button class="finished-btn" id="replayBtn"><i class="fas fa-redo"></i> Replay Episode</button>
        </div>

        <video id="customPlayer" playsinline autoplay preload="metadata" crossOrigin="anonymous"></video>

        <div class="seek-overlay left" id="seekOverlayLeft"></div>
        <div class="seek-overlay right" id="seekOverlayRight"></div>
        <div class="seek-feedback left" id="seekFeedbackRewind"><i class="fas fa-undo-alt"></i> -10s</div>
        <div class="seek-feedback right" id="seekFeedbackForward"><i class="fas fa-redo-alt"></i> +10s</div>
        <div class="big-play-button" id="bigPlayBtn"><i class="fas fa-play"></i></div>
        <div class="skip-button" id="skipBtn">Skip <i class="fas fa-forward"></i></div>

        <div class="video-controls" id="videoControls">
            <div class="progress-bar-container" id="progressBarContainer">
                <div class="thumbnail-tooltip" id="thumbnailTooltip">
                    <div class="thumbnail-image" id="thumbnailImage"></div>
                    <div class="thumbnail-time" id="thumbnailTime">0:00</div>
                </div>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-bar-hover" id="progressBarHover"></div>
                    <div class="progress-filled" id="progressFilled"></div>
                </div>
            </div>

            <div class="controls-main">
                <div class="controls-left">
                    <button class="control-button" id="playPauseBtn" aria-label="Play/Pause"><i class="fas fa-play"></i></button>
                    <button class="control-button" id="volumeBtn" aria-label="Mute/Unmute"><i class="fas fa-volume-up"></i></button>
                    <div class="volume-container">
                        <input type="range" class="volume-slider" id="volumeSlider" min="0" max="1" step="0.01" value="1">
                    </div>
                    <span class="time-display" id="currentTime">0:00</span>
                </div>

                <div class="controls-center">
                    <button class="control-button" id="rewindBtn" aria-label="Rewind 10 seconds"><i class="fas fa-undo-alt"></i></button>
                    <button class="control-button" id="forwardBtn" aria-label="Forward 10 seconds"><i class="fas fa-redo-alt"></i></button>
                </div>

                <div class="controls-right">
                    <span class="time-display" id="totalTime">0:00</span>
                    <div style="position: relative;">
                        <button class="control-button" id="captionsBtn" aria-label="Captions" style="display: none;">
                            <i class="fas fa-closed-captioning"></i>
                        </button>
                        <div class="captions-menu" id="captionsMenu"></div>
                    </div>
                    <button class="control-button" id="fullscreenBtn" aria-label="Fullscreen"><i class="fas fa-expand"></i></button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let ffmpegLoaded = false;
        let FFmpeg, FFmpegUtil;

        async function loadFFmpeg() {
            try {
                const ffmpegScript = document.createElement('script');
                ffmpegScript.src = 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js';
                const utilScript = document.createElement('script');
                utilScript.src = 'https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js';
                
                await Promise.all([
                    new Promise((resolve, reject) => { ffmpegScript.onload = resolve; ffmpegScript.onerror = reject; document.head.appendChild(ffmpegScript); }),
                    new Promise((resolve, reject) => { utilScript.onload = resolve; utilScript.onerror = reject; document.head.appendChild(utilScript); })
                ]);
                
                FFmpeg = window.FFmpeg;
                FFmpegUtil = window.FFmpegUtil;
                ffmpegLoaded = true;
            } catch (error) {
                console.warn('FFmpeg not available:', error);
                ffmpegLoaded = false;
            }
        }
        loadFFmpeg();
    </script>


    <script>
        const playerContainer = document.getElementById('videoPlayerContainer');
        const video = document.getElementById('customPlayer');
        const videoControls = document.getElementById('videoControls');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const bigPlayBtn = document.getElementById('bigPlayBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const volumeBtn = document.getElementById('volumeBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const progressFilled = document.getElementById('progressFilled');
        const progressBarHover = document.getElementById('progressBarHover');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const loadingContainer = document.getElementById('loadingContainer');
        const loadingText = document.getElementById('loadingText');
        const seekOverlayLeft = document.getElementById('seekOverlayLeft');
        const seekOverlayRight = document.getElementById('seekOverlayRight');
        const seekFeedbackRewind = document.getElementById('seekFeedbackRewind');
        const seekFeedbackForward = document.getElementById('seekFeedbackForward');
        const skipBtn = document.getElementById('skipBtn');
        const captionsBtn = document.getElementById('captionsBtn');
        const captionsMenu = document.getElementById('captionsMenu');
        const thumbnailTooltip = document.getElementById('thumbnailTooltip');
        const thumbnailImage = document.getElementById('thumbnailImage');
        const thumbnailTime = document.getElementById('thumbnailTime');
        const finishedOverlay = document.getElementById('finishedOverlay');
        const replayBtn = document.getElementById('replayBtn');

        let controlsTimeout;
        let lastTapTimeLeft = 0;
        let lastTapTimeRight = 0;
        const doubleTapDelay = 300; 
        let feedbackTimeout;
        let ffmpeg; 
        let skipTimes = null;
        let thumbnailsData = [];
        let saveInterval = 0; // Throttling variable

        if (!('ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0)) {
            playerContainer.classList.add('desktop');
        }

        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            const config = {
                video: params.get('video'),
                isStream: params.get('stream') === 'true',
                full: params.get('full') === 'true',
                referer: params.get('referer'),
                id: params.get('id'),         // MAL ID
                episode: params.get('episode'), // Episode Number/ID
                skipTimes: null,
                captions: null,
                thumbnails: null,
                series_title: params.get('series_title'),
                episode_num: params.get('episode_num'),
                thumbnail_url: params.get('thumbnail_url')
            };

            try { if (params.get('skip_times')) config.skipTimes = JSON.parse(params.get('skip_times')); } catch(e) {}
            try { if (params.get('captions')) config.captions = JSON.parse(params.get('captions')); } catch(e) {}
            try { if (params.get('thumbnails')) config.thumbnails = JSON.parse(params.get('thumbnails')); } catch(e) {}
            return config;
        }

        const config = getQueryParams();
        updateMediaSessionMetadata();

        // --- Media Session API Logic ---
        function updateMediaSessionMetadata() {
            if ('mediaSession' in navigator && config.series_title && config.episode_num) {
                const title = `${config.series_title} - EP ${config.episode_num}`;
                const artwork = [];
                if (config.thumbnail_url) {
                    artwork.push({ src: config.thumbnail_url, sizes: '512x512', type: 'image/jpeg' }); // Assuming JPEG, can be dynamic if needed
                }

                navigator.mediaSession.metadata = new MediaMetadata({
                    title: title,
                    artist: config.series_title, // Using series title as artist for consistency
                    artwork: artwork
                });
                console.log("Media Session Metadata Updated:", navigator.mediaSession.metadata);
            }
        }

        // --- LOCAL STORAGE LOGIC ---
        // All watch history is now local only. No server/cloud sync.
        const STORAGE_KEY = 'animex_watch_history';

        function loadProgress(malId, episode) {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                if (!data) return null;
                const history = JSON.parse(data);
                if (history[malId] && history[malId][episode]) {
                    return history[malId][episode];
                }
            } catch(e) { console.error("Load progress failed", e); }
            return null;
        }

        function saveProgress(malId, episode, timestamp, state) {
            // Respect 'finished' state if explicitly passed, otherwise default to 'ongoing'
            let actualState = state;
            if (state !== 'finished' && video && video.duration && timestamp < video.duration - 2) {
                actualState = 'ongoing';
            }
            console.log("Saving progress:", malId, episode, timestamp, actualState);
            if (!malId || !episode) return;
            try {
                let history = {};
                const data = localStorage.getItem(STORAGE_KEY);
                if (data) history = JSON.parse(data);

                if (!history[malId]) history[malId] = {};
                
                history[malId][episode] = {
                    timestamp: timestamp,
                    state: actualState, // 'ongoing' or 'finished'
                    last_watched: new Date().toISOString(),
                    episode_length: video && video.duration ? video.duration : 0
                };

                localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
            } catch(e) { console.error("Save progress failed", e); }

            // Send progress to parent if in iframe
            if (window.parent && window !== window.parent) {
                window.parent.postMessage({
                    type: 'animex-progress',
                    malId: malId,
                    episode: episode,
                    timestamp: timestamp,
                    state: actualState,
                    last_watched: new Date().toISOString(),
                    episode_length: video && video.duration ? video.duration : 0
                }, '*');
            }
        }

        function getProxyUrl(url) {
            if (!config.referer) return url;
            if (url.includes('/proxy?')) return url;
            return `/proxy?url=${encodeURIComponent(url)}&referer=${encodeURIComponent(config.referer)}`;
        }

        function parseTimestamp(timeStr) {
            const parts = timeStr.split(':');
            let seconds = 0;
            if (parts.length === 3) seconds = parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
            else if (parts.length === 2) seconds = parseInt(parts[0]) * 60 + parseFloat(parts[1]);
            return seconds;
        }

        async function loadThumbnails(thumbConfig) {
            if (!thumbConfig || thumbConfig.length === 0) return;
            const vttItem = thumbConfig.find(t => t.kind === 'thumbnails');
            if (!vttItem) return;

            try {
                const fetchUrl = getProxyUrl(vttItem.file);
                const response = await fetch(fetchUrl);
                const text = await response.text();
                const baseUrl = vttItem.file.substring(0, vttItem.file.lastIndexOf('/') + 1);
                
                const lines = text.split(/\r?\n/);
                let currentStart = null;
                let currentEnd = null;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line || line === 'WEBVTT') continue;
                    if (line.includes('-->')) {
                        const times = line.split('-->');
                        currentStart = parseTimestamp(times[0].trim());
                        currentEnd = parseTimestamp(times[1].trim());
                    } else if (currentStart !== null && line.includes('#xywh=')) {
                        const [filename, coords] = line.split('#xywh=');
                        const [x, y, w, h] = coords.split(',').map(Number);
                        const absUrl = filename.startsWith('http') ? filename : baseUrl + filename;
                        thumbnailsData.push({
                            start: currentStart,
                            end: currentEnd,
                            url: getProxyUrl(absUrl),
                            x, y, w, h
                        });
                        currentStart = null;
                    }
                }
            } catch (err) { console.error("Failed to load thumbnails", err); }
        }

        function renderSkipMarkers(duration) {
            if (!skipTimes || !duration) return;
            document.querySelectorAll('.skip-marker').forEach(e => e.remove());

            if (skipTimes.intro) {
                const [start, end] = skipTimes.intro;
                const left = (start / duration) * 100;
                const width = ((end - start) / duration) * 100;
                const marker = document.createElement('div');
                marker.className = 'skip-marker intro';
                marker.style.left = `${left}%`;
                marker.style.width = `${width}%`;
                progressBar.appendChild(marker);
            }
            if (skipTimes.outro) {
                const [start, end] = skipTimes.outro;
                const left = (start / duration) * 100;
                const width = ((end - start) / duration) * 100;
                const marker = document.createElement('div');
                marker.className = 'skip-marker outro';
                marker.style.left = `${left}%`;
                marker.style.width = `${width}%`;
                progressBar.appendChild(marker);
            }
        }

        const initPlayer = async () => {
            if (!config.video) {
                playerContainer.innerHTML = '<p style="color:white; text-align:center; padding: 20px;">Error: No video specified.</p>';
                return;
            }
            if (config.full) playerContainer.classList.add('fullscreen-mode');
            if (config.thumbnails) loadThumbnails(config.thumbnails);
            if (config.skipTimes) skipTimes = config.skipTimes;
            if (config.captions) setupCaptions(config.captions); 

            // --- RESTORE PROGRESS LOGIC ---
            const savedProgress = loadProgress(config.id, config.episode);
            let startAtTime = 0;
            let alreadyFinished = false;

            if (savedProgress) {
                // Always load the saved timestamp
                startAtTime = savedProgress.timestamp || 0;
                
                // Check if we're at/near the end of the episode (timestamp-wise, not state)
                if (video && video.duration && startAtTime >= (video.duration - 2)) {
                    alreadyFinished = true;
                } else if (!video.duration) {
                    // If duration is not known yet, defer check until loadedmetadata
                    alreadyFinished = 'pending';
                }
            }

            const url = decodeURIComponent(config.video);
            
            if (config.isStream) {
                if (Hls.isSupported()) {
                    class ProxyLoader extends Hls.DefaultConfig.loader {
                        constructor(config) {
                            super(config);
                            var load = this.load.bind(this);
                            this.load = function(context, config, callbacks) {
                                if (window.playerConfig && window.playerConfig.referer) {
                                    const originalUrl = context.url;
                                    context.url = `/proxy?url=${encodeURIComponent(context.url)}&referer=${encodeURIComponent(window.playerConfig.referer)}`;
                                    const originalOnSuccess = callbacks.onSuccess;
                                    callbacks.onSuccess = function(response, stats, context) {
                                        response.url = originalUrl; 
                                        originalOnSuccess(response, stats, context);
                                    };
                                }
                                load(context, config, callbacks);
                            };
                        }
                    }

                    window.playerConfig = config;

                    const hls = new Hls({
                        loader: config.referer ? ProxyLoader : Hls.DefaultConfig.loader,
                        autoStartLoad: true
                    });

                    hls.loadSource(url);
                    hls.attachMedia(video);
                    
                    hls.on(Hls.Events.ERROR, function(event, data) {
                        if (data.fatal) {
                            switch(data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR: hls.startLoad(); break;
                                case Hls.ErrorTypes.MEDIA_ERROR: hls.recoverMediaError(); break;
                                default: hls.destroy(); break;
                            }
                        }
                    });
                    
                    // Seek after metadata loads
                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        if (startAtTime > 0 && !alreadyFinished) {
                            video.currentTime = startAtTime;
                        }
                    });

                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    video.src = getProxyUrl(url);
                    if (startAtTime > 0 && !alreadyFinished) {
                        video.addEventListener('loadedmetadata', () => { video.currentTime = startAtTime; }, {once:true});
                    }
                } else {
                    loadingText.textContent = "Error: HLS not supported on this browser";
                    playerContainer.classList.add('error');
                }
            } 
            else if (url.toLowerCase().endsWith('.mkv')) {
                 if (!ffmpegLoaded) {
                    playerContainer.classList.add('error');
                    loadingText.textContent = 'MKV requires internet';
                    return;
                }
                playerContainer.classList.add('processing');
                loadingText.textContent = 'Processing video...';
                 try {
                    if (!ffmpeg) {
                        ffmpeg = new FFmpeg.FFmpeg();
                        await ffmpeg.load({ coreURL: "https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js" });
                    }
                    const inputData = await FFmpegUtil.fetchFile(getProxyUrl(url));
                    await ffmpeg.writeFile('input.mkv', inputData);
                    await ffmpeg.exec(['-i', 'input.mkv', '-c', 'copy', 'output.mp4']);
                    const outputData = await ffmpeg.readFile('output.mp4');
                    video.src = URL.createObjectURL(new Blob([outputData.buffer], { type: 'video/mp4' }));
                    playerContainer.classList.remove('processing');
                    loadingText.textContent = '';
                    
                    if (startAtTime > 0 && !alreadyFinished) {
                         video.currentTime = startAtTime;
                    }

                } catch (error) {
                    console.error(error);
                    playerContainer.classList.add('error');
                }
            } else {
                video.src = getProxyUrl(url);
                if (startAtTime > 0 && !alreadyFinished) {
                    video.addEventListener('loadedmetadata', () => { video.currentTime = startAtTime; }, {once:true});
                }
            }

            // Handle Initial "Finished" State
            if (alreadyFinished === true) {
                video.currentTime = 0; // Reset visual position to start, but paused
                finishedOverlay.classList.add('visible');
                playerContainer.classList.remove('loading');
            } else if (alreadyFinished === 'pending') {
                // Wait for loadedmetadata to check if at end
                video.addEventListener('loadedmetadata', () => {
                    if (savedProgress && savedProgress.state === 'finished' && savedProgress.timestamp >= (video.duration - 2)) {
                        video.currentTime = 0;
                        finishedOverlay.classList.add('visible');
                        playerContainer.classList.remove('loading');
                    } else if (startAtTime > 0) {
                        video.currentTime = startAtTime;
                        video.play().catch(() => {
                            video.muted = true;
                            video.play().catch(e => console.log("Autoplay blocked", e));
                        });
                    } else {
                        video.play().catch(() => {
                            video.muted = true;
                            video.play().catch(e => console.log("Autoplay blocked", e));
                        });
                    }
                }, {once:true});
            } else {
                video.play().catch(() => {
                    video.muted = true;
                    video.play().catch(e => console.log("Autoplay blocked", e));
                });
            }
        };

        // --- REPLAY LOGIC ---
        replayBtn.addEventListener('click', () => {
            finishedOverlay.classList.remove('visible');
            video.currentTime = 0;
            saveProgress(config.id, config.episode, 0, 'ongoing'); // Reset state
            video.play();
        });

        async function setupCaptions(captionsList) {
            if (!captionsList || captionsList.length === 0) return;
            captionsBtn.style.display = 'block';

            const offBtn = document.createElement('button');
            offBtn.className = 'caption-option selected';
            offBtn.textContent = 'Off';
            offBtn.onclick = () => setCaptionTrack(-1);
            captionsMenu.appendChild(offBtn);

            let defaultTrackIndex = -1;

            for (let i = 0; i < captionsList.length; i++) {
                const cap = captionsList[i];
                const proxyUrl = getProxyUrl(cap.file);
                
                try {
                    const response = await fetch(proxyUrl);
                    if (!response.ok) throw new Error("Failed to fetch caption");
                    const vttText = await response.text();
                    
                    const vttBlob = new Blob([vttText], { type: 'text/vtt' });
                    const trackUrl = URL.createObjectURL(vttBlob);
                    
                    const track = document.createElement('track');
                    track.kind = 'subtitles';
                    track.label = cap.label;
                    track.srclang = 'en'; 
                    track.src = trackUrl;
                    
                    if (cap.default) {
                        track.default = true;
                        defaultTrackIndex = i;
                    }
                    
                    video.appendChild(track);
                    
                    const btn = document.createElement('button');
                    btn.className = 'caption-option';
                    btn.textContent = cap.label;
                    const trackIndex = video.textTracks.length - 1; 
                    btn.onclick = () => setCaptionTrack(trackIndex);
                    captionsMenu.appendChild(btn);

                } catch (e) {
                    console.error("Could not load caption:", cap.label, e);
                }
            }

            if (defaultTrackIndex !== -1) {
                setTimeout(() => {
                   setCaptionTrack(defaultTrackIndex);
                }, 100);
            }
        }

        function setCaptionTrack(index) {
            for (let i = 0; i < video.textTracks.length; i++) {
                video.textTracks[i].mode = (i === index) ? 'showing' : 'hidden';
            }
            
            if (index === -1) captionsBtn.classList.remove('active');
            else captionsBtn.classList.add('active');
            
            const options = captionsMenu.children;
            for (let i = 0; i < options.length; i++) {
                options[i].classList.remove('selected');
            }
            if (options[index + 1]) options[index + 1].classList.add('selected');
            
            captionsMenu.style.display = 'none';
        }

        captionsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            captionsMenu.style.display = (captionsMenu.style.display === 'flex') ? 'none' : 'flex';
        });
        document.addEventListener('click', (e) => {
            if (!captionsBtn.contains(e.target) && !captionsMenu.contains(e.target)) captionsMenu.style.display = 'none';
        });

        document.addEventListener('DOMContentLoaded', initPlayer);
        video.addEventListener('waiting', () => { playerContainer.classList.add('loading'); loadingText.textContent = "Loading..."; });
        video.addEventListener('canplay', () => { playerContainer.classList.remove('loading'); loadingText.textContent = ""; });
        video.addEventListener('playing', () => { playerContainer.classList.remove('loading'); loadingText.textContent = ""; });
        
        // Handle Video End = Finished
        video.addEventListener('ended', () => {
             saveProgress(config.id, config.episode, video.duration, 'finished');
             finishedOverlay.classList.add('visible');
             hideControls();
        });

        function togglePlay() {
            if (finishedOverlay.classList.contains('visible')) return;
            playerContainer.classList.add('has-interacted');
            if (video.paused || video.ended) video.play().catch(console.error);
            else video.pause();
        }
        playPauseBtn.addEventListener('click', togglePlay);
        bigPlayBtn.addEventListener('click', togglePlay);
        
        let videoTapTimeout;
        video.addEventListener('click', (event) => {
            if (event.target === seekOverlayLeft || event.target === seekOverlayRight) return;
            if (event.detail === 1) {
                videoTapTimeout = setTimeout(() => {
                     if (playerContainer.classList.contains('controls-active') && !video.paused) hideControls();
                     else togglePlay();
                }, 200);
            }
        });

        video.addEventListener('play', () => {
            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
            playerContainer.classList.add('playing');
            playerContainer.classList.remove('paused');
            hideControlsWithDelay();
        });
        video.addEventListener('pause', () => {
            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
            playerContainer.classList.remove('playing');
            playerContainer.classList.add('paused');
            showControls();
        });

        rewindBtn.addEventListener('click', () => { video.currentTime -= 10; });
        forwardBtn.addEventListener('click', () => { video.currentTime += 10; });

        video.addEventListener('loadedmetadata', () => {
            totalTimeEl.textContent = formatTime(video.duration);
            progressFilled.style.width = '0%';
            renderSkipMarkers(video.duration);
        });

        video.addEventListener('timeupdate', () => {
            const currentTime = video.currentTime;
            currentTimeEl.textContent = formatTime(currentTime);
            if (video.duration) progressFilled.style.width = `${(currentTime / video.duration) * 100}%`;

            let currentState = 'ongoing';

            // Check Skip Markers & Finish State
            if (skipTimes) {
                let showSkip = false;
                let skipTarget = 0;
                let skipLabel = "Skip";

                // Intro Skip
                if (skipTimes.intro && currentTime >= skipTimes.intro[0] && currentTime < skipTimes.intro[1]) {
                    showSkip = true; skipTarget = skipTimes.intro[1]; skipLabel = "Skip Intro";
                }
                // Outro Skip + Finish Logic
                if (skipTimes.outro && currentTime >= skipTimes.outro[0]) {
                    // If in outro region, show skip button
                    if (currentTime < skipTimes.outro[1]) {
                        showSkip = true; skipTarget = skipTimes.outro[1]; skipLabel = "Skip Outro";
                    }
                    // If after outro start (including after outro end), mark as finished
                    currentState = 'finished';
                }

                if (showSkip) {
                    skipBtn.classList.add('visible');
                    skipBtn.innerHTML = `${skipLabel} <i class="fas fa-forward"></i>`;
                    skipBtn.onclick = () => { video.currentTime = skipTarget; };
                } else { skipBtn.classList.remove('visible'); }
            }

            // --- SAVE PROGRESS EVERY 1 SEC ---
            const now = Date.now();
            if (now - saveInterval > 1000) {
                saveProgress(config.id, config.episode, currentTime, currentState);
                saveInterval = now;
                // If we determined it's finished via Outro logic (but video hasn't ended),
                // we DO NOT stop the video, we just save the state as finished.
                // The overlay only shows on video.ended event or initial load.
            }
        });

        function formatTime(t) {
            if (isNaN(t) || t < 0) return "0:00";
            const m = Math.floor(t / 60);
            const s = Math.floor(t % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        progressBarContainer.addEventListener('click', (e) => {
            const rect = progressBar.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percentage = Math.max(0, Math.min(1, clickX / rect.width));
            video.currentTime = percentage * video.duration;
        });
        
        progressBarContainer.addEventListener('mousemove', (e) => {
            if (!video.duration) return;
            const rect = progressBar.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            progressBarHover.style.width = `${pos * 100}%`;
            
            if (thumbnailsData.length > 0) {
                const hoverTime = pos * video.duration;
                thumbnailTooltip.style.display = 'flex';
                thumbnailTooltip.style.left = `${e.clientX - progressBarContainer.getBoundingClientRect().left}px`;
                thumbnailTime.textContent = formatTime(hoverTime);
                const frame = thumbnailsData.find(t => hoverTime >= t.start && hoverTime < t.end);
                if (frame) {
                    thumbnailImage.style.width = `${frame.w}px`;
                    thumbnailImage.style.height = `${frame.h}px`;
                    thumbnailImage.style.backgroundImage = `url('${frame.url}')`;
                    thumbnailImage.style.backgroundPosition = `-${frame.x}px -${frame.y}px`;
                }
            }
        });
        progressBarContainer.addEventListener('mouseleave', () => {
            progressBarHover.style.width = `0%`;
            thumbnailTooltip.style.display = 'none';
        });

        function toggleMute() { video.muted = !video.muted; }
        volumeBtn.addEventListener('click', toggleMute);
        video.addEventListener('volumechange', () => {
            volumeSlider.value = video.volume;
            if (video.muted || video.volume === 0) { volumeBtn.innerHTML = '<i class="fas fa-volume-mute"></i>'; volumeSlider.value = 0; }
            else if (video.volume < 0.5) volumeBtn.innerHTML = '<i class="fas fa-volume-down"></i>';
            else volumeBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
        });
        volumeSlider.addEventListener('input', (e) => { video.volume = e.target.value; video.muted = e.target.value === '0'; });

        function isFullscreen() { return !!(document.fullscreenElement || document.webkitFullscreenElement || video.webkitDisplayingFullscreen); }
        function toggleFullscreen() {
            if (video.webkitEnterFullscreen) {
                if (video.webkitDisplayingFullscreen) video.webkitExitFullscreen();
                else video.webkitEnterFullscreen();
            } else {
                if (isFullscreen()) { if (document.exitFullscreen) document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); }
                else { if (playerContainer.requestFullscreen) playerContainer.requestFullscreen(); else if (playerContainer.webkitRequestFullscreen) playerContainer.webkitRequestFullscreen(); }
            }
        }
        function updateFullscreenVisuals() {
            if (isFullscreen()) { fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>'; playerContainer.classList.add('fullscreen'); }
            else { fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>'; playerContainer.classList.remove('fullscreen'); }
        }
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        video.addEventListener('dblclick', (event) => {
            clearTimeout(videoTapTimeout);
            if (event.target === seekOverlayLeft || event.target === seekOverlayRight) return;
            toggleFullscreen();
        });
        ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(e => document.addEventListener(e, updateFullscreenVisuals));
        video.addEventListener('webkitbeginfullscreen', updateFullscreenVisuals);
        video.addEventListener('webkitendfullscreen', updateFullscreenVisuals);

        function showControls() { clearTimeout(controlsTimeout); playerContainer.classList.add('controls-active'); }
        function hideControls() { if (video.paused) return; playerContainer.classList.remove('controls-active'); }
        function hideControlsWithDelay() { if (video.paused) return; clearTimeout(controlsTimeout); controlsTimeout = setTimeout(hideControls, 3000); }
        
        playerContainer.addEventListener('mousemove', () => { showControls(); hideControlsWithDelay(); });
        playerContainer.addEventListener('mouseleave', () => { if (!video.paused) hideControls(); });
        videoControls.addEventListener('mouseenter', showControls);
        videoControls.addEventListener('mouseleave', hideControlsWithDelay);
        playerContainer.addEventListener('touchstart', (e) => {
            if (e.target.closest('.control-button') || e.target.closest('.skip-button')) return;
            if (!playerContainer.classList.contains('controls-active')) showControls();
            hideControlsWithDelay();
        }, { passive: true });

        function showSeekFeedback(el) { clearTimeout(feedbackTimeout); el.classList.add('show'); feedbackTimeout = setTimeout(() => el.classList.remove('show'), 600); }
        seekOverlayLeft.addEventListener('click', (e) => {
            e.stopPropagation();
            const now = Date.now();
            if (now - lastTapTimeLeft < doubleTapDelay) { clearTimeout(videoTapTimeout); video.currentTime -= 10; showSeekFeedback(seekFeedbackRewind); lastTapTimeLeft = 0; }
            else { lastTapTimeLeft = now; if (playerContainer.classList.contains('controls-active') && !video.paused) hideControls(); else { showControls(); hideControlsWithDelay(); } }
        });
        seekOverlayRight.addEventListener('click', (e) => {
            e.stopPropagation();
            const now = Date.now();
            if (now - lastTapTimeRight < doubleTapDelay) { clearTimeout(videoTapTimeout); video.currentTime += 10; showSeekFeedback(seekFeedbackForward); lastTapTimeRight = 0; }
            else { lastTapTimeRight = now; if (playerContainer.classList.contains('controls-active') && !video.paused) hideControls(); else { showControls(); hideControlsWithDelay(); } }
        });

        document.addEventListener('keydown', (e) => {
            if (document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
            switch(e.key.toLowerCase()) {
                case ' ': case 'k': e.preventDefault(); togglePlay(); break;
                case 'arrowleft': case 'j': e.preventDefault(); video.currentTime -= 10; break;
                case 'arrowright': case 'l': e.preventDefault(); video.currentTime += 10; break;
                case 'arrowup': e.preventDefault(); if(video.volume < 1) video.volume = Math.min(1, video.volume + 0.1); break;
                case 'arrowdown': e.preventDefault(); if(video.volume > 0) video.volume = Math.max(0, video.volume - 0.1); break;
                case 'm': e.preventDefault(); toggleMute(); break;
                case 'f': e.preventDefault(); toggleFullscreen(); break;
            }
        });
    </script>
</body>
</html>