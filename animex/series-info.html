<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Series Info - Media App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />
    <!-- Add after the existing font-awesome link -->
    <link
      rel="stylesheet"
      href="https://abtp2.github.io/csPlayer/src/csPlayer.css"
    />
    <script src="https://www.youtube.com/iframe_api"></script>
    <link rel="stylesheet" href="Resources/series.css" />

  </head>
  <body>
    <div class="app-container">
      <!-- ****** START: ADD BACK BUTTON ****** -->
      <script>
        // This script block remains as is, as it's needed for initial setup.
        document.addEventListener("DOMContentLoaded", () => {
          const urlParams = new URLSearchParams(window.location.search);
          const showBackBtn = urlParams.get("anime") === "true";
          const backBtn = document.getElementById("back-button");
          if (backBtn) {
            backBtn.style.display = showBackBtn ? "" : "none";
          }
        });
      </script>
      <!-- ****** END: ADD BACK BUTTON ****** -->

      <header class="series-hero-section">
        <button id="back-button" class="back-btn">
          <i class="fas fa-arrow-left"></i>
        </button>
        <div class="series-hero-content">
          <!-- Inside <div class="series-hero-content"> -->
          <h1 class="series-title-text"></h1>

          <div class="hero-actions">
            <!-- This button is populated by JS -->
            <button
              id="hero-watch-btn"
              class="hero-watch-btn"
              style="display: none"
            >
              <i class="fas fa-play"></i> <span>Start Watching</span>
            </button>

            <!-- Existing buttons -->
            <button
              id="add-series-to-list-btn"
              class="hero-action-btn"
              title="Add to List"
            >
              <i class="fas fa-bookmark"></i> Add to List
            </button>
            <button
              id="export-series-btn"
              class="hero-action-btn"
              title="Export"
            >
              <i class="fas fa-download"></i> Export
            </button>
          </div>
        </div>
        <div class="hero-overlay"></div>
      </header>

      <main class="main-content series-main-content">
        <!-- ****** START: UPDATED DETAILS SECTION WITH COLLAPSIBLE WRAPPER ****** -->
        <section class="series-details-section">
          <div class="series-meta-info">
            <span id="series-score"></span>
            <span id="series-year"></span>
            <span id="series-type"></span>
            <span id="series-episodes-count"></span>
            <span id="series-status"></span>
            <span id="series-rating"></span>
          </div>

          <div id="details-content-wrapper" class="details-content-wrapper">
            <div class="details-grid">
              <div>
                <!-- Left Column -->
                <p id="series-synopsis"></p>
              </div>
              <div>
                <!-- Right Column -->
                <div id="series-info-additional">
                  <p>
                    <strong>English Title:</strong>
                    <span id="series-title-english"></span>
                  </p>
                  <p>
                    <strong>Japanese Title:</strong>
                    <span id="series-title-japanese"></span>
                  </p>
                  <p>
                    <strong>Source:</strong> <span id="series-source"></span>
                  </p>
                  <p>
                    <strong>Duration:</strong>
                    <span id="series-duration"></span>
                  </p>
                </div>
                <div class="series-genres"></div>
                <div class="series-studios"></div>
                <div class="series-producers"></div>
              </div>
            </div>
            <section
              class="trailer-section"
              id="trailer-section"
              style="display: none"
            >
              <div class="trailer-player-container">
                <h3 class="trailer-title">
                  <i class="fas fa-play-circle"></i>
                  Trailer
                </h3>
                <div id="trailer-player"></div>
              </div>
            </section>
          </div>

          <div
            id="show-more-container"
            class="show-more-container"
            style="display: none"
          >
            <button id="show-more-btn" class="show-more-btn">
              <span>Show More</span> <i class="fas fa-chevron-down"></i>
            </button>
          </div>
        </section>
        <!-- ****** END: UPDATED DETAILS SECTION ****** -->

        <!-- ****** START: TABS SYSTEM HTML ****** -->
        <section class="tabs-section" id="tabs-section" style="display: none">
          <div class="tabs-container" id="tabs-container">
            <button class="tab-btn active" data-tab="episodes">Episode</button>
            <button class="tab-btn" data-tab="related">Related</button>
            <button class="tab-btn" data-tab="recommendations">
              More Like This
            </button>
          </div>
          <div class="tab-content-container">
            <!-- Episodes Panel -->
            <div id="tab-panel-episodes" class="tab-panel active">
              <section class="episode-list-section">
                <div class="section-header">
                  <h2 class="section-title">Episode List</h2>
                  <div class="season-selector-container" style="display: none">
                    <select
                      id="season-selector"
                      class="season-selector"
                      title="Select a season"
                    ></select>
                  </div>
                  <button
                    id="thumbnail-toggle-btn"
                    class="thumbnail-toggle-btn"
                    title="Toggle Thumbnails"
                  >
                    <i class="fas fa-image"></i>
                  </button>
                </div>
                <div class="episodes-loader" id="episodes-loader"></div>
                <div class="episode-list" id="episode-list-container"></div>
                <div id="episodes-pagination" class="episodes-pagination"></div>
              </section>
              <div
                id="next-season-btn-container"
                style="text-align: center; margin-top: 2rem; display: none"
              >
                <button id="next-season-btn" class="show-more-btn">
                  <i class="fas fa-forward"></i> Next Season
                </button>
              </div>
            </div>
            <!-- Related Panel -->
            <div id="tab-panel-related" class="tab-panel">
              <div
                class="related-content-container"
                id="related-content-container"
              >
                <!-- Related content will be generated by JS -->
              </div>
            </div>
            <!-- Recommendations Panel -->
            <div id="tab-panel-recommendations" class="tab-panel">
              <div class="content-grid" id="recommendations-grid">
                <!-- Recommendation cards will be generated by JS -->
              </div>
            </div>
          </div>
        </section>
        <!-- ****** END: TABS SYSTEM HTML ****** -->
      </main>
    </div>

    <!-- Episode Pop-up Overlay -->
    <div
      id="episode-popup-overlay"
      class="episode-popup-overlay"
      style="display: none"
    >
      <div class="episode-popup-content">
        <button class="episode-popup-back" title="Back">
          <i class="fas fa-arrow-left"></i>
        </button>
        <iframe
          id="episode-popup-iframe"
          src=""
          frameborder="0"
          allowfullscreen
        ></iframe>
      </div>
    </div>

    <!-- Confirmation Pop-up -->
    <div
      id="confirmation-popup-overlay"
      class="episode-popup-overlay"
      style="display: none"
    >
      <div id="confirmation-popup-content" class="confirmation-popup-content">
        <h3 id="confirmation-popup-title">Heads Up!</h3>
        <p id="confirmation-popup-message"></p>
        <div class="confirmation-popup-buttons">
          <button id="confirm-btn" class="popup-btn confirm">
            Watch Again
          </button>
          <button id="cancel-btn" class="popup-btn cancel">Cancel</button>
        </div>
      </div>
    </div>

    <script src="src/csplayer.js"></script>

    <script>
      function loadLocalWatchHistory() {
        try {
          const history = localStorage.getItem("animex_watch_history");
          localWatchHistory = history ? JSON.parse(history) : {};
        } catch (e) {
          localWatchHistory = {};
        }
      }
      window.addEventListener("message", (event) => {});

      document.addEventListener("DOMContentLoaded", () => {
        loadLocalWatchHistory();
        // ****** START: BACK BUTTON LOGIC ******
        const urlParams = new URLSearchParams(window.location.search);
        const isAnime = urlParams.get("anime") === "true";
        const isManga = urlParams.get("manga") === "true";
        const isLibrary = urlParams.get("library") === "true";
        const type = urlParams.get("type") || (isManga ? "manga" : "anime");
        const API_BASE_URL = "https://arkm20-authapi.hf.space";
        const serverIp = localStorage.getItem("extension_server_ip");
        // At the top of the script, with the other global variables
        let currentProfile = null;

        const serverUrl = `http://${serverIp}:7275`;
        let localWatchHistory = {};
        // All watch history is now local only. Removed userWatchHistory and isSyncing.
        const backButton = document.getElementById("back-button");
        if (backButton) {
          backButton.style.display =
            isAnime || isManga || isLibrary ? "" : "none";
          backButton.addEventListener("click", () => {
            if (isLibrary === true) {
              window.location.href = "library.html";
            } else {
              window.location.href = isManga ? "manga.html" : "anime.html";
            }
          });
        }
        // ****** END: BACK BUTTON LOGIC ******

        const heroSection = document.querySelector(".series-hero-section");
        const seriesTitleTextElement =
          document.querySelector(".series-title-text");
        // NEW: Selector for the hero add to list button
        const addSeriesToListBtn = document.getElementById(
          "add-series-to-list-btn"
        );

        const seriesScoreElement = document.getElementById("series-score");
        const seriesYearElement = document.getElementById("series-year");
        const seriesTypeElement = document.getElementById("series-type");
        const seriesEpisodesCountElement = document.getElementById(
          "series-episodes-count"
        );
        const seriesStatusElement = document.getElementById("series-status");
        const seriesRatingElement = document.getElementById("series-rating");
        const seriesSynopsisElement =
          document.getElementById("series-synopsis");
        const seriesGenresContainer = document.querySelector(".series-genres");
        const seriesStudiosContainer =
          document.querySelector(".series-studios");
        const seriesProducersContainer =
          document.querySelector(".series-producers");

        const seriesTitleEnglishElement = document.getElementById(
          "series-title-english"
        );
        const seriesTitleJapaneseElement = document.getElementById(
          "series-title-japanese"
        );
        const seriesSourceElement = document.getElementById("series-source");
        const seriesDurationElement =
          document.getElementById("series-duration");

        const episodeListContainer = document.getElementById(
          "episode-list-container"
        );
        const episodesPaginationContainer = document.getElementById(
          "episodes-pagination"
        );
        const thumbnailToggleBtn = document.getElementById(
          "thumbnail-toggle-btn"
        );
        const episodesLoader = document.getElementById("episodes-loader");

        const seasonSelectorContainer = document.querySelector(
          ".season-selector-container"
        );
        const seasonSelector = document.getElementById("season-selector");

        const tabsSection = document.getElementById("tabs-section");
        const tabsContainer = document.getElementById("tabs-container");
        const tabPanels = document.querySelectorAll(".tab-panel");
        const relatedContainer = document.getElementById(
          "related-content-container"
        );
        const recommendationsContainer = document.getElementById(
          "recommendations-grid"
        );

        // ****** START: COLLAPSIBLE DETAILS SELECTORS ******
        const detailsWrapper = document.getElementById(
          "details-content-wrapper"
        );
        const showMoreContainer = document.getElementById(
          "show-more-container"
        );
        const showMoreBtn = document.getElementById("show-more-btn");
        const showMoreBtnText = showMoreBtn.querySelector("span");
        // ****** END: COLLAPSIBLE DETAILS SELECTORS ******

        let currentMalId = null;
        let currentKitsuId = null;
        let currentSeriesTitle = "";
        let episodesData = [];
        let currentPage = 1;
        const episodesPerPage = 25;

        if (type !== "anime") {
          if (tabsSection) tabsSection.style.display = "none";
          // NEW: Hide hero add button for non-anime types on this page
          if (addSeriesToListBtn) addSeriesToListBtn.style.display = "none";
        }

        function getSeriesIdFromUrl() {
          const params = new URLSearchParams(window.location.search);
          return params.get("id");
        }

        async function getKitsuId(malId) {
          try {
            const response = await fetch(`${serverUrl}/map/mal/${malId}`);
            if (!response.ok) throw new Error("Mapping API failed");
            const data = await response.json();
            return data.kitsu_id;
          } catch (error) {
            console.error(`Failed to map MAL ID ${malId} to Kitsu ID:`, error);
            return null;
          }
        }

        async function fetchKitsuData(kitsuId) {
          try {
            if (!kitsuId) return null;
            const response = await fetch(
              `https://kitsu.io/api/edge/anime/${kitsuId}`
            );
            if (!response.ok) throw new Error("Kitsu API failed");
            const data = await response.json();
            return data.data;
          } catch (error) {
            console.error(
              `Failed to fetch Kitsu data for ID ${kitsuId}:`,
              error
            );
            return null;
          }
        }

        async function fetchSeriesDetails(seriesId) {
          try {
            const response = await fetch(
              `https://api.jikan.moe/v4/${type}/${seriesId}/full`
            );
            if (!response.ok)
              throw new Error(
                `Jikan API error (details): ${response.status} ${response.statusText}`
              );
            const data = await response.json();
            return data.data;
          } catch (error) {
            console.error(`Failed to fetch ${type} details:`, error);
            displayError(
              "Could not load series details. Please try again later."
            );
          }
        }

        async function fetchSeriesEpisodes(kitsuId) {
          if (type !== "anime" || !kitsuId) return [];
          let allEpisodes = [];
          let url = `https://kitsu.io/api/edge/anime/${kitsuId}/episodes?page[limit]=20`;

          try {
            while (url) {
              const response = await fetch(url);
              if (!response.ok) {
                console.warn(
                  `Failed to fetch Kitsu episode page: ${response.status}`
                );
                break;
              }
              const data = await response.json();
              if (data.data && data.data.length > 0) {
                allEpisodes = allEpisodes.concat(data.data);
              }
              url = data.links?.next || null;
              if (url) await new Promise((resolve) => setTimeout(resolve, 200));
            }
            allEpisodes.sort(
              (a, b) => a.attributes.number - b.attributes.number
            );
            return allEpisodes;
          } catch (error) {
            console.error("Failed to fetch Kitsu episodes:", error);
            document.getElementById("tab-panel-episodes").innerHTML =
              '<p class="info-message">Could not load episodes.</p>';
            if (episodesLoader) episodesLoader.style.display = "none";
            return [];
          }
        }

        async function fetchSeriesEpisodesFromJikanVideos(malId) {
          if (type !== "anime" || !malId) return [];
          try {
            const response = await fetch(
              `https://api.jikan.moe/v4/anime/${malId}/videos`
            );
            if (!response.ok) {
              console.warn(`Failed to fetch Jikan videos: ${response.status}`);
              return [];
            }
            const data = await response.json();
            const episodes = data?.data?.episodes || [];

            // Adapt Jikan episode format to Kitsu-like format for compatibility
            return episodes
              .map((ep) => ({
                attributes: {
                  number: ep.mal_id,
                  canonicalTitle: ep.title,
                  seasonNumber: 1, // Jikan doesn't provide this, assume 1
                  thumbnail: {
                    small:
                      ep.images?.jpg?.image_url ||
                      "https://placehold.co/320x180/1f1f1f/FFF?text=?",
                  },
                },
              }))
              .sort((a, b) => a.attributes.number - b.attributes.number);
          } catch (error) {
            console.error(
              "Failed to fetch Jikan episodes from /videos endpoint:",
              error
            );
            return [];
          }
        }

        async function fetchRelations(seriesId) {
          try {
            const response = await fetch(
              `https://api.jikan.moe/v4/anime/${seriesId}/relations`
            );
            if (!response.ok)
              throw new Error(
                `Jikan API error (relations): ${response.status}`
              );
            const data = await response.json();
            return data.data;
          } catch (error) {
            console.error("Failed to fetch relations:", error);
            return [];
          }
        }

        async function fetchRecommendations(seriesId) {
          try {
            const response = await fetch(
              `https://api.jikan.moe/v4/anime/${seriesId}/recommendations`
            );
            if (!response.ok)
              throw new Error(
                `Jikan API error (recommendations): ${response.status}`
              );
            const data = await response.json();
            return data.data;
          } catch (error) {
            console.error("Failed to fetch recommendations:", error);
            return [];
          }
        }

        function cleanSynopsis(synopsis) {
          if (!synopsis) return "No synopsis available.";
          return synopsis.replace(/\[Written by MAL Rewrite\]/gi, "").trim();
        }

        async function getImage(malId) {
          try {
            const response = await fetch(
              `${serverUrl}/anime/image?mal_id=${malId}`
            );
            if (!response.ok) throw new Error("Failed to fetch MAL data");
            const data = await response.json();
            return data.image;
          } catch (error) {
            console.error("Failed to fetch MAL image:", error);
            return null;
          }
        }

        async function displayAnimeDetails(anime, kitsuData) {
          if (!anime) return;
          const customImage = await getImage(currentMalId).catch(() => null);
          const jikanImage =
            anime.images?.jpg?.large_image_url || anime.images?.jpg?.image_url;
          const heroImageUrl =
            customImage ||
            jikanImage ||
            "https://placehold.co/1200x700/141414/FFF?text=No+Image";

          heroSection.style.backgroundImage = `url('${heroImageUrl}')`;
          const displayTitle = anime.title_english || anime.title;
          currentSeriesTitle = displayTitle;
          seriesTitleTextElement.textContent = displayTitle;
          document.title = `${displayTitle} - Series Info`;
          seriesScoreElement.textContent = anime.score
            ? `Score: ${anime.score}`
            : "N/A";
          seriesYearElement.textContent = `${
            anime.year || anime.aired?.prop?.from?.year || "N/A"
          }`;
          seriesTypeElement.textContent = `${anime.type || "N/A"}`;
          seriesEpisodesCountElement.textContent = `${
            anime.episodes || "N/A"
          } Episodes`;
          seriesStatusElement.textContent = `${anime.status || "N/A"}`;
          seriesRatingElement.textContent = `${anime.rating || "N/A"}`;
          seriesSynopsisElement.innerHTML = cleanSynopsis(
            anime.synopsis
          ).replace(/\n/g, "<br>");
          seriesTitleEnglishElement.textContent = anime.title_english || "N/A";
          seriesTitleJapaneseElement.textContent =
            anime.title_japanese || "N/A";
          seriesSourceElement.textContent = anime.source || "N/A";
          seriesDurationElement.textContent = anime.duration || "N/A";
          seriesGenresContainer.innerHTML = "<strong>Genres:</strong> ";
          [
            ...anime.genres,
            ...(anime.explicit_genres || []),
            ...(anime.themes || []),
            ...(anime.demographics || []),
          ].forEach((g) => {
            const genreSpan = document.createElement("span");
            genreSpan.textContent = g.name;
            seriesGenresContainer.appendChild(genreSpan);
          });
          seriesStudiosContainer.innerHTML = "<strong>Studios:</strong> ";
          anime.studios.forEach((s) => {
            const studioSpan = document.createElement("span");
            studioSpan.textContent = s.name;
            seriesStudiosContainer.appendChild(studioSpan);
          });
          seriesProducersContainer.innerHTML = "<strong>Producers:</strong> ";
          anime.producers.forEach((p) => {
            const producerSpan = document.createElement("span");
            producerSpan.textContent = p.name;
            seriesProducersContainer.appendChild(producerSpan);
          });
          if (type === "anime" && kitsuData) {
            setupTrailerPlayer(kitsuData);
          }
        }

        function displayEpisodes(episodes) {
          if (episodesLoader) episodesLoader.style.display = "none";
          if (!episodes || episodes.length === 0) {
            document.getElementById("tab-panel-episodes").innerHTML =
              '<p class="info-message">No episodes found for this series.</p>';
            return;
          }
          episodesData = episodes;
          currentPage = 1;
          renderEpisodePage();
          setupPagination(episodesData.length);
          startEpisodeClassPolling();

          updateHeroWatchButton();
        }

        async function displayRelations(relations) {
          relatedContainer.innerHTML = "";
          if (!relations || relations.length === 0) {
            relatedContainer.innerHTML =
              '<p class="info-message">No related content found.</p>';
            return;
          }

          relatedContainer.innerHTML =
            '<div class="episodes-loader" style="display: block;"></div>'; // Show loader

          const allEntries = relations.flatMap((rel) =>
            rel.entry.map((e) => ({ ...e, relation: rel.relation }))
          );

          const fetchKitsuPoster = async (entry) => {
            let poster = "https://placehold.co/80x120/1f1f1f/FFF?text=N/A";
            if (entry.type === "anime") {
              const kitsuId = await getKitsuId(entry.mal_id);
              const kitsuData = await fetchKitsuData(kitsuId);
              poster =
                kitsuData?.attributes?.posterImage?.small ||
                "https://placehold.co/80x120/1f1f1f/FFF?text=Anime";
            } else if (entry.type === "manga") {
              poster =
                `https://api.jikan.moe/v4/manga/${entry.mal_id}/pictures`.includes(
                  ".jpg"
                )
                  ? `https://api.jikan.moe/v4/manga/${entry.mal_id}/pictures`
                  : "https://placehold.co/80x120/1f1f1f/FFF?text=Manga";
            }
            return { ...entry, poster };
          };

          const entriesWithPosters = await Promise.all(
            allEntries.map(fetchKitsuPoster)
          );

          relatedContainer.innerHTML = ""; // Clear loader

          entriesWithPosters.forEach((entry) => {
            const card = document.createElement("a");
            card.className = "related-card";
            card.href = `series-info.html?id=${entry.mal_id}`;

            const displayTitle = entry.title_english || entry.name;
            card.title = displayTitle;

            const imgContainer = document.createElement("div");
            imgContainer.className = "related-card-img-container";

            const img = document.createElement("img");
            img.className = "related-card-img";
            img.src = entry.poster;
            img.alt = `Poster for ${displayTitle}`;
            img.loading = "lazy";
            imgContainer.appendChild(img);

            const infoDiv = document.createElement("div");
            infoDiv.className = "related-card-info";

            const title = document.createElement("h4");
            title.className = "related-card-title";
            title.textContent = displayTitle;

            const tag = document.createElement("span");
            tag.className = "related-card-tag";
            tag.textContent = entry.relation;

            infoDiv.appendChild(title);
            infoDiv.appendChild(tag);

            card.appendChild(imgContainer);
            card.appendChild(infoDiv);
            relatedContainer.appendChild(card);
          });
        }

        function displayRecommendations(recommendations) {
          recommendationsContainer.innerHTML = "";
          if (!recommendations || recommendations.length === 0) {
            recommendationsContainer.innerHTML =
              '<p class="info-message">No recommendations found.</p>';
            return;
          }

          recommendations.slice(0, 18).forEach((rec) => {
            const entry = rec.entry;
            const card = document.createElement("a");
            card.className = "recommendation-card";
            card.href = `series-info.html?id=${entry.mal_id}`;

            // Prioritize English title if available (though often not in this endpoint)
            const displayTitle = entry.title_english || entry.title;
            card.title = displayTitle;

            const imgContainer = document.createElement("div");
            imgContainer.className = "recommendation-card-img-container";

            const img = document.createElement("img");
            img.className = "recommendation-card-img";
            img.src =
              entry.images.jpg.large_image_url || entry.images.jpg.image_url;
            img.alt = `Poster for ${displayTitle}`;
            img.loading = "lazy";

            const title = document.createElement("div");
            title.className = "recommendation-card-title";
            title.textContent = displayTitle;

            imgContainer.appendChild(img);
            card.appendChild(imgContainer);
            card.appendChild(title);
            recommendationsContainer.appendChild(card);
          });
        }

        // Removed updateUserWatchHistoryOnApi. All watch history is now local only.

        function updateLocalWatchHistory(
          seriesId,
          seasonNumber,
          episodeNumber,
          seriesTitle
        ) {
          if (!seriesId || !episodeNumber) return;
          if (!localWatchHistory[seriesId]) localWatchHistory[seriesId] = {};
          if (!localWatchHistory[seriesId][episodeNumber])
            localWatchHistory[seriesId][episodeNumber] = {};
          localWatchHistory[seriesId][episodeNumber] = {
            timestamp: 0,
            state: "finished",
            last_watched: new Date().toISOString(),
          };
          try {
            localStorage.setItem(
              "animex_watch_history",
              JSON.stringify(localWatchHistory)
            );
          } catch (e) {
            console.error("Failed to save local watch history", e);
          }
          // All watch history is now local only. No server update.
        }

        // Removed syncWatchHistory. All watch history is now local only.

        function isEpisodeWatched(seriesId, seasonNumber, episodeNumber) {
          // Only check local watch history
          if (
            localWatchHistory &&
            localWatchHistory[seriesId]?.[episodeNumber]
          ) {
            return localWatchHistory[seriesId][episodeNumber];
          }
          return null;
        }

        function renderEpisodePage() {
          const container = document.getElementById("episode-list-container");
          container.innerHTML = "";

          const start = (currentPage - 1) * episodesPerPage;
          const end = start + episodesPerPage;
          const paginatedEpisodes = episodesData.slice(start, end);

          paginatedEpisodes.forEach((episode) => {
            const epNum = episode.attributes.number;

            // Create Card
            const card = document.createElement("div");
            card.className = "episode-item";
            card.dataset.episodeNumber = epNum;
            card.dataset.seasonNumber = episode.attributes.seasonNumber || 1;

            // Check Watch History for CSS class
            const history = localWatchHistory?.[currentMalId]?.[epNum];
            if (history) {
              if (history.state === "finished") card.classList.add("watched");
              else if (history.state === "ongoing")
                card.classList.add("ongoing");
            }

            // 1. Thumbnail Section
            const thumbDiv = document.createElement("div");
            thumbDiv.className = "episode-thumbnail";
            const img = document.createElement("img");
            img.className = "episode-thumbnail-img";
            img.src =
              episode.attributes.thumbnail?.small ||
              "https://placehold.co/320x180/202020/666?text=No+Image";
            img.loading = "lazy";
            thumbDiv.appendChild(img);

            // 2. Info Section
            const infoDiv = document.createElement("div");
            infoDiv.className = "episode-info";

            const title = document.createElement("div");
            title.className = "episode-title";
            title.textContent =
              episode.attributes.canonicalTitle || `Episode ${epNum}`;

            const subTitle = document.createElement("div");
            subTitle.className = "episode-title-romanji";
            // Fallback logic for romanji/number display
            subTitle.textContent = `Episode ${epNum}`;

            infoDiv.appendChild(title);
            infoDiv.appendChild(subTitle);

            // 3. Actions Section
            const actionsDiv = document.createElement("div");
            actionsDiv.className = "episode-action-buttons";

            // Download Btn
            const dlBtn = document.createElement("button");
            dlBtn.className = "episode-action-icon";
            dlBtn.title = "Download";
            dlBtn.innerHTML = '<i class="fas fa-cloud-download-alt"></i>';
            dlBtn.onclick = (e) => {
              e.stopPropagation();
              let quality = localStorage.getItem("quality") || "720p";
              window.open(
                `${serverUrl}/download?mal_id=${currentMalId}&episode=${epNum}&dub=true&quality=${quality}`,
                "_blank"
              );
            };

            // Add to List Btn
            const listBtn = document.createElement("button");
            listBtn.className = "episode-action-icon";
            listBtn.title = "Add to List";
            listBtn.innerHTML = '<i class="fas fa-plus"></i>';
            listBtn.onclick = (e) => {
              e.stopPropagation();
              if (window.parent && window.parent.openListManager) {
                window.parent.openListManager({
                  type: "anime",
                  id: currentMalId,
                  title: currentSeriesTitle,
                  items: [String(epNum)],
                  source: "jikan",
                });
              }
            };

            actionsDiv.appendChild(listBtn);
            actionsDiv.appendChild(dlBtn);

            // Assemble
            card.appendChild(thumbDiv);
            card.appendChild(infoDiv);
            card.appendChild(actionsDiv);

            // Main Click
            card.onclick = (e) => {
              if (e.target.closest(".episode-action-icon")) return;
              const refererUrl = encodeURIComponent(window.location.href);
              const url = `view.html?id=${encodeURIComponent(
                currentMalId
              )}&ep=${encodeURIComponent(epNum)}&referer=${refererUrl}`;
              openEpisodePopup(url);
            };

            container.appendChild(card);
          });
        }

        function pollAndUpdateEpisodeClasses() {
          try {
            const historyRaw = localStorage.getItem("animex_watch_history");
            const history = historyRaw ? JSON.parse(historyRaw) : {};
            const seriesId = String(currentMalId);
            const items =
              episodeListContainer.querySelectorAll(".episode-item");
            items.forEach((item) => {
              const epNum = item.dataset.episodeNumber;
              const seasonNum = item.dataset.seasonNumber;
              let state = null;
              if (history[seriesId] && history[seriesId][epNum]) {
                state = history[seriesId][epNum].state;
              }
              item.classList.remove("watched", "ongoing");
              if (state === "finished") {
                item.classList.add("watched");
              } else if (state === "ongoing") {
                item.classList.add("ongoing");
              }
            });
          } catch (e) {
            // Ignore errors
          }
        }

        // Start polling every second after episodes are rendered
        let pollInterval = null;
        function startEpisodeClassPolling() {
          if (pollInterval) clearInterval(pollInterval);
          pollAndUpdateEpisodeClasses();
          pollInterval = setInterval(pollAndUpdateEpisodeClasses, 1000);
        }

        async function setupTrailerPlayer(kitsuData) {
          const trailerSection = document.getElementById("trailer-section");
          const trailerPlayer = document.getElementById("trailer-player");
          if (!kitsuData || !kitsuData.attributes.youtubeVideoId) {
            trailerSection.style.display = "none";
            return;
          }
          const youtubeId = kitsuData.attributes.youtubeVideoId;
          try {
            trailerSection.style.display = "block";
            const isMobile =
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              );
            if (isMobile) {
              trailerPlayer.innerHTML = `<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; background: var(--background-tertiary);"><iframe src="https://www.youtube.com/embed/${youtubeId}?rel=0&modestbranding=1&playsinline=1&enablejsapi=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen title="Anime Trailer"></iframe></div>`;
            } else {
              try {
                csPlayer.init("trailer-player", {
                  defaultId: youtubeId,
                  thumbnail: true,
                  theme: "default",
                  loop: false,
                  autoplay: false,
                });
              } catch (csPlayerError) {
                console.warn(
                  "csPlayer failed, falling back to iframe:",
                  csPlayerError
                );
                trailerPlayer.innerHTML = `<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; background: var(--background-tertiary);"><iframe src="https://www.youtube.com/embed/${youtubeId}?rel=0&modestbranding=1&enablejsapi=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen title="Anime Trailer"></iframe></div>`;
              }
            }
            console.log(`Trailer loaded for YouTube ID: ${youtubeId}`);
          } catch (error) {
            console.error("Failed to initialize trailer player:", error);
            trailerPlayer.innerHTML = `<div class="no-trailer-message" style="text-align: center; padding: 2rem;"><p style="margin-bottom: 1rem; color: var(--text-muted);">Trailer available on YouTube</p><a href="https://www.youtube.com/watch?v=${youtubeId}" target="_blank" style="display: inline-block; padding: 0.75rem 1.5rem; background: var(--brand-accent); color: var(--background-primary); text-decoration: none; border-radius: 6px; font-weight: 500;"><i class="fab fa-youtube" style="margin-right: 0.5rem;"></i> Watch on YouTube</a></div>`;
          }
        }

        function setupPagination(totalEpisodes) {
          episodesPaginationContainer.innerHTML = "";
          const pageCount = Math.ceil(totalEpisodes / episodesPerPage);
          if (pageCount <= 1) return;
          const prevButton = document.createElement("button");
          prevButton.innerHTML = "« Prev";
          prevButton.disabled = currentPage === 1;
          prevButton.addEventListener("click", () => {
            if (currentPage > 1) {
              currentPage--;
              renderEpisodePage();
              updatePaginationButtons(pageCount);
              window.scrollTo(
                0,
                document.getElementById("tabs-section").offsetTop
              );
            }
          });
          episodesPaginationContainer.appendChild(prevButton);
          const pageInfo = document.createElement("span");
          pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
          episodesPaginationContainer.appendChild(pageInfo);
          const nextButton = document.createElement("button");
          nextButton.innerHTML = "Next »";
          nextButton.disabled = currentPage === pageCount;
          nextButton.addEventListener("click", () => {
            if (currentPage < pageCount) {
              currentPage++;
              renderEpisodePage();
              updatePaginationButtons(pageCount);
              window.scrollTo(
                0,
                document.getElementById("tabs-section").offsetTop
              );
            }
          });
          episodesPaginationContainer.appendChild(nextButton);
        }

        function updatePaginationButtons(pageCount) {
          const prevButton =
            episodesPaginationContainer.querySelector("button:first-child");
          const nextButton =
            episodesPaginationContainer.querySelector("button:last-child");
          const pageInfo = episodesPaginationContainer.querySelector("span");
          if (prevButton) prevButton.disabled = currentPage === 1;
          if (nextButton) nextButton.disabled = currentPage === pageCount;
          if (pageInfo)
            pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
        }

        function displayError(message) {
          const mainContent = document.querySelector(".series-main-content");
          if (mainContent)
            mainContent.innerHTML = `<p class="error-message" style="color: #ff6b6b; text-align: center; padding: 30px; font-size: 1.2em;">${message}</p>`;
          if (heroSection) heroSection.style.display = "none";
          if (backButton && message.includes("No series ID specified"))
            backButton.style.display = "none";
        }

        function setupThumbnailToggle() {
          const storageKey = "showEpisodeThumbnails";
          let showThumbnails = localStorage.getItem(storageKey) !== "false";
          function applyPreference() {
            if (showThumbnails) {
              episodeListContainer.classList.remove("thumbnails-hidden");
              thumbnailToggleBtn.classList.add("active");
            } else {
              episodeListContainer.classList.add("thumbnails-hidden");
              thumbnailToggleBtn.classList.remove("active");
            }
          }
          thumbnailToggleBtn.addEventListener("click", () => {
            showThumbnails = !showThumbnails;
            localStorage.setItem(storageKey, showThumbnails);
            applyPreference();
          });
          applyPreference();
        }

        function setupTabs() {
          tabsContainer.addEventListener("click", (e) => {
            const targetTab = e.target.closest(".tab-btn");
            if (!targetTab) return;

            tabsContainer
              .querySelectorAll(".tab-btn")
              .forEach((btn) => btn.classList.remove("active"));
            tabPanels.forEach((panel) => panel.classList.remove("active"));

            targetTab.classList.add("active");
            const tabName = targetTab.dataset.tab;
            const activePanel = document.getElementById(`tab-panel-${tabName}`);
            if (activePanel) {
              activePanel.classList.add("active");
            }
          });
        }

        async function fetchAndDisplaySeasons(malId) {
          try {
            const response = await fetch(`${serverUrl}/anime/${malId}/seasons`);
            if (!response.ok) throw new Error("Failed to fetch seasons");
            const seasons = await response.json();

            if (seasons && seasons.length > 1) {
              seasonSelector.innerHTML = "";
              seasons.forEach((season, index) => {
                const option = document.createElement("option");
                option.value = season.mal_id;
                const seasonLabel = `Season ${index + 1}`;
                option.textContent = `${seasonLabel}: ${season.title}`;
                option.dataset.fullTitle = season.title;

                if (String(season.mal_id) === String(malId)) {
                  option.selected = true;
                }
                seasonSelector.appendChild(option);
              });
              seasonSelectorContainer.style.display = "block";
            } else {
              seasonSelectorContainer.style.display = "none";
            }
          } catch (error) {
            console.error("Failed to load seasons:", error);
            seasonSelectorContainer.style.display = "none";
          }
        }

        function formatSeconds(seconds) {
          if (!seconds || seconds < 0) return "0:00";
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
          return `${mins}:${secs}`;
        }

        // Call this function inside displayEpisodes() or after episodesData is loaded
        function updateHeroWatchButton() {
          const watchBtn = document.getElementById("hero-watch-btn");
          if (!episodesData || episodesData.length === 0) {
            watchBtn.style.display = "none";
            return;
          }

          watchBtn.style.display = "inline-flex";
          const seriesId = String(currentMalId);
          let mostRecentWatchedEpNumber = 0;
          let mostRecentWatchedEpData = null;

          if (localWatchHistory && localWatchHistory[seriesId]) {
            let latestTimestamp = 0;
            for (const epNum in localWatchHistory[seriesId]) {
              const epData = localWatchHistory[seriesId][epNum];
              if (epData.last_watched) {
                const currentTimestamp = new Date(epData.last_watched).getTime();
                if (currentTimestamp > latestTimestamp) {
                  latestTimestamp = currentTimestamp;
                  mostRecentWatchedEpNumber = parseInt(epNum, 10);
                  mostRecentWatchedEpData = epData;
                }
              }
            }
          }

          let targetEpNumber = 1; // Default to Ep 1
          let labelText = "Start Watching EP 1";
          let iconClass = "fa-play";

          if (mostRecentWatchedEpNumber > 0 && mostRecentWatchedEpData) {
            const { state, timestamp, episode_length } = mostRecentWatchedEpData;
            const progressThreshold = 0.9; // e.g., if watched > 90% assume finished
            const isCloseToFinished = episode_length > 0 && (timestamp / episode_length) > progressThreshold;

            if (state === "finished" || isCloseToFinished) {
              // User finished last watched ep or nearly finished, suggest next one
              const nextEp = episodesData.find(
                (ep) => ep.attributes.number > mostRecentWatchedEpNumber
              );
              if (nextEp) {
                targetEpNumber = nextEp.attributes.number;
                labelText = `Continue Watching EP ${targetEpNumber}`;
              } else {
                // All episodes watched, suggest re-watching from first
                targetEpNumber = 1;
                labelText = "Re-watch Series";
                iconClass = "fa-rotate-right";
              }
            } else {
              // User is in middle of an episode
              targetEpNumber = mostRecentWatchedEpNumber;
              const timeRemaining = episode_length - timestamp;
              labelText = `Continue Watching EP ${targetEpNumber} (${formatSeconds(timestamp)})`;
            }
          }

          // Update Button UI
          watchBtn.innerHTML = `<i class="fas ${iconClass}"></i> ${labelText}`;

          // Update Click Event
          watchBtn.onclick = () => {
            // The handleEpisodeToWatchOnLoad will now contain the logic to determine which episode to truly open
            handleEpisodeToWatchOnLoad(targetEpNumber, true); // true = skipApiWait if data loaded
          };
        }

        seasonSelector.addEventListener("change", async (event) => {
          const newMalId = event.target.value;
          if (newMalId === currentMalId) return;

          currentMalId = newMalId;

          const selectedOption =
            seasonSelector.options[seasonSelector.selectedIndex];
          currentSeriesTitle = selectedOption.dataset.fullTitle;

          episodeListContainer.innerHTML = "";
          episodesPaginationContainer.innerHTML = "";
          if (episodesLoader) episodesLoader.style.display = "block";

          let newEpisodes = [];
          const newKitsuId = await getKitsuId(currentMalId);
          if (newKitsuId) {
            newEpisodes = await fetchSeriesEpisodes(newKitsuId);
          }
          if (!newEpisodes || newEpisodes.length === 0) {
            newEpisodes = await fetchSeriesEpisodesFromJikanVideos(
              currentMalId
            );
          }
          displayEpisodes(newEpisodes);
        });

        function setupCollapsibleDetails() {
          // Use a timeout to ensure content has rendered and scrollHeight is accurate
          setTimeout(() => {
            const collapsedHeight = parseInt(
              window.getComputedStyle(detailsWrapper).maxHeight,
              10
            );
            // Check if content is overflowing, with a buffer
            if (detailsWrapper.scrollHeight > collapsedHeight + 50) {
              showMoreContainer.style.display = "block";

              showMoreBtn.addEventListener("click", () => {
                const isExpanded = detailsWrapper.classList.toggle("expanded");
                showMoreBtnText.textContent = isExpanded
                  ? "Show Less"
                  : "Show More";
              });
            } else {
              // If no overflow, remove the fade effect and the button container itself.
              detailsWrapper.style.maxHeight = "none";
              detailsWrapper.classList.add("expanded"); // This removes the ::after pseudo-element
              showMoreContainer.style.display = "none";
            }
          }, 800); // Delay to allow images/trailer to load and affect scrollHeight
        }

        async function handleEpisodeToWatchOnLoad(
          episodeToWatch,
          skipApiWait = false
        ) {
          if (!episodeToWatch) return;
          const episodeNumberToFind = parseInt(episodeToWatch, 10);
          if (isNaN(episodeNumberToFind)) return;

          // If skip-api flag is set and we don't have episodes data yet, open instantly
          if (skipApiWait && (!episodesData || episodesData.length === 0)) {
            // Open directly without waiting for episodes to load
            const refererUrl = encodeURIComponent(
              window.location.href.split("&watch-ep=")[0].split("&skip-api=")[0]
            );
            const url = `view.html?id=${encodeURIComponent(
              currentMalId
            )}&ep=${encodeURIComponent(
              episodeNumberToFind
            )}&referer=${refererUrl}`;
            openEpisodePopup(url);
            return;
          }

          // Otherwise wait for episodes data
          if (!episodesData || !episodesData.length) return;

          const episodeIndex = episodesData.findIndex(
            (ep) => ep.attributes.number === episodeNumberToFind
          );
          if (episodeIndex > -1) {
            const episode = episodesData[episodeIndex];
            const seasonNumber = episode.attributes.seasonNumber || 1; // Default to 1 if not available
            const epHistory = localWatchHistory?.[currentMalId]?.[episodeNumberToFind];

            const openPlayer = (targetEpisodeNumber) => {
              const targetEpisodeIndex = episodesData.findIndex(
                (ep) => ep.attributes.number === targetEpisodeNumber
              );
              if (targetEpisodeIndex > -1) {
                const targetPage = Math.ceil(
                  (targetEpisodeIndex + 1) / episodesPerPage
                );
                if (currentPage !== targetPage) {
                  currentPage = targetPage;
                  renderEpisodePage();
                  updatePaginationButtons(
                    Math.ceil(episodesData.length / episodesPerPage)
                  );
                }
                const episodeItems =
                  episodeListContainer.querySelectorAll(".episode-item");
                const itemIndexOnPage = targetEpisodeIndex % episodesPerPage;
                if (episodeItems[itemIndexOnPage]) {
                  episodeItems[itemIndexOnPage].classList.add("watched"); // Mark as watched when opening
                }
                const refererUrl = encodeURIComponent(
                  window.location.href
                    .split("&watch-ep=")[0]
                    .split("&skip-api=")[0]
                );
                const url = `view.html?id=${encodeURIComponent(
                  currentMalId
                )}&ep=${encodeURIComponent(
                  targetEpisodeNumber
                )}&referer=${refererUrl}`;
                openEpisodePopup(url);
              }
            };

            let targetEpisode = episodeNumberToFind;
            if (epHistory) {
              const { state, timestamp, episode_length } = epHistory;
              const progressThreshold = 0.9; // If watched > 90% assume finished
              const isMostlyFinished = episode_length > 0 && (timestamp / episode_length) > progressThreshold;

              if (state === "finished" || isMostlyFinished) {
                // If finished or mostly finished, suggest next episode
                const nextEp = episodesData[episodeIndex + 1];
                if (nextEp) {
                  targetEpisode = nextEp.attributes.number;
                }
              }
            }
            openPlayer(targetEpisode);
          }
        }

        // NEW: Event listener for hero "Add to List" button
        if (addSeriesToListBtn) {
          addSeriesToListBtn.addEventListener("click", () => {
            if (type === "anime" && episodesData.length > 0) {
              const allEpisodeNumbers = episodesData.map((ep) =>
                String(ep.attributes.number)
              );
              if (
                window.parent &&
                typeof window.parent.openListManager === "function"
              ) {
                window.parent.openListManager({
                  type: "anime",
                  id: currentMalId,
                  title: currentSeriesTitle,
                  items: allEpisodeNumbers,
                  source: "jikan",
                });
              }
            }
          });
        }

        // NEW: Event listener for hero "Export" button
        const exportSeriesBtn = document.getElementById("export-series-btn");
        if (exportSeriesBtn) {
          exportSeriesBtn.addEventListener("click", () => {
            if (!currentMalId || !type) {
              window.parent.showToast("Series information not loaded yet.");
              return;
            }
            const serverIp = localStorage.getItem("extension_server_ip");
            if (!serverIp) {
              window.parent.showToast("Server IP not configured.");
              return;
            }
            const serverUrl = `http://${serverIp}:7275`;
            const exportUrl = `${serverUrl}/export/series/${currentMalId}?type=${type}`;

            window.open(exportUrl, "_blank");
          });
        }

        async function init() {
          const params = new URLSearchParams(window.location.search);
          currentMalId = params.get("id");
          // In the init() function, right after setting up toggles and tabs
          // const profileId = localStorage.getItem("currentProfileId"); // Removed: No longer need to check access token
          // if (profileId) {
          //   try {
          //     // const response = await fetch(`/profiles/${profileId}`);
          //     const response = await fetch(`/profiles/${profileId}`);
          //     if (response.ok) {
          //       currentProfile = await response.json();
          //     } else {
          //       console.warn(
          //         "Could not fetch current profile. Watch history will be disabled."
          //       );
          //     }
          //   } catch (e) {
          //     console.error("Error fetching profile:", e);
          //   }
          // }
          const episodeToWatchOnLoad = params.get("watch-ep");
          const skipApiWait = params.get("skip-api") === "true";
          if (!currentMalId) {
            displayError(
              "No series ID specified in the URL. Example: series-info.html?id=5114"
            );
            return;
          }

          setupThumbnailToggle();
          setupTabs();
          console.log("Fetching series details for MAL ID:", currentMalId);
          loadLocalWatchHistory();

          const seriesDetails = await fetchSeriesDetails(currentMalId);

          if (seriesDetails) {
            // All watch history is now local only. No sync.

            if (type === "anime") {
              if (tabsSection) tabsSection.style.display = "block";

              currentKitsuId = await getKitsuId(currentMalId);
              const kitsuData = await fetchKitsuData(currentKitsuId);

              await displayAnimeDetails(seriesDetails, kitsuData);
              await fetchAndDisplaySeasons(currentMalId);
              setupCollapsibleDetails();

              if (episodesLoader) episodesLoader.style.display = "block";

              let episodes = [];
              if (currentKitsuId) {
                episodes = await fetchSeriesEpisodes(currentKitsuId);
              }

              if (!episodes || episodes.length === 0) {
                // Fallback to Jikan
                console.log(
                  "Kitsu episodes not found, falling back to Jikan..."
                );
                episodes = await fetchSeriesEpisodesFromJikanVideos(
                  currentMalId
                );
                if (episodes && episodes.length > 0) {
                  // Display a message to the user
                  const episodeListSection = document.querySelector(
                    ".episode-list-section"
                  );
                  if (episodeListSection) {
                    const warning = document.createElement("p");
                    warning.textContent =
                      "Episode data is from a fallback source and may be incomplete.";
                    warning.className = "info-message fallback-warning";
                    episodeListSection.prepend(warning);
                  }
                }
              }

              const [relations, recommendations] = await Promise.all([
                fetchRelations(currentMalId),
                fetchRecommendations(currentMalId),
              ]);

              displayEpisodes(episodes);
              displayRelations(relations);
              displayRecommendations(recommendations);

              if (episodeToWatchOnLoad)
                await handleEpisodeToWatchOnLoad(
                  episodeToWatchOnLoad,
                  skipApiWait
                );
            } else {
              // Manga logic
              if (tabsSection) tabsSection.style.display = "none";
              await displayAnimeDetails(seriesDetails, null);
              setupCollapsibleDetails();
            }
          }
        }

        // --- POPUP OVERLAY LOGIC ---
        const popupOverlay = document.getElementById("episode-popup-overlay");
        const popupIframe = document.getElementById("episode-popup-iframe");
        function openEpisodePopup(url) {
          popupIframe.src = url;
          popupOverlay.style.display = "flex";
          setTimeout(() => popupOverlay.classList.add("active"), 10);
          document.body.style.overflow = "hidden";
        }
        function closeEpisodePopup() {
          popupOverlay.classList.remove("active");
          setTimeout(() => {
            popupOverlay.style.display = "none";
            popupIframe.src = "";
            document.body.style.overflow = "";
          }, 300);
        }
        const popupBackBtn = popupOverlay.querySelector(".episode-popup-back");
        popupBackBtn.addEventListener("click", closeEpisodePopup);
        popupOverlay.addEventListener("click", (e) => {
          if (e.target === popupOverlay) closeEpisodePopup();
        });

        // --- CONFIRMATION POPUP LOGIC ---
        const confirmOverlay = document.getElementById(
          "confirmation-popup-overlay"
        );
        const confirmMessage = document.getElementById(
          "confirmation-popup-message"
        );
        const confirmBtn = document.getElementById("confirm-btn");
        const cancelBtn = document.getElementById("cancel-btn");
        let confirmCallback = null;
        function showConfirmation(message, onConfirm) {
          confirmMessage.textContent = message;
          confirmCallback = onConfirm;
          confirmOverlay.style.display = "flex";
          setTimeout(() => confirmOverlay.classList.add("active"), 10);
          document.body.style.overflow = "hidden";
        }
        function closeConfirmation() {
          confirmOverlay.classList.remove("active");
          setTimeout(() => {
            confirmOverlay.style.display = "none";
            document.body.style.overflow = "";
          }, 300);
        }
        confirmBtn.addEventListener("click", () => {
          if (confirmCallback) confirmCallback();
          closeConfirmation();
        });
        cancelBtn.addEventListener("click", closeConfirmation);
        confirmOverlay.addEventListener("click", (e) => {
          if (e.target === confirmOverlay) closeConfirmation();
        });

        init();
      });
    </script>
  </body>
</html>
